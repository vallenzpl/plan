//深度优先遍历
void depthFirstSearch(Tree root){
    stack<Node *> nodeStack;  //使用C++的STL标准模板库
    nodeStack.push(root);
    Node *node;
    while(!nodeStack.empty()){
        node = nodeStack.top();
        printf(format, node->data);  //遍历根结点
        nodeStack.pop();
        if(node->rchild){
            nodeStack.push(node->rchild);  //先将右子树压栈
        }
        if(node->lchild){
            nodeStack.push(node->lchild);  //再将左子树压栈
        }
    }
}
 
//广度优先遍历
void breadthFirstSearch(Tree root){
    queue<Node *> nodeQueue;  //使用C++的STL标准模板库
    nodeQueue.push(root);
    Node *node;
    while(!nodeQueue.empty()){
        node = nodeQueue.front();
        nodeQueue.pop();
        printf(format, node->data);
        if(node->lchild){
            nodeQueue.push(node->lchild);  //先将左子树入队
        }
        if(node->rchild){
            nodeQueue.push(node->rchild);  //再将右子树入队
        }
    }
}


－－－


void DFS(Node root)   //非递归实现  
{  
    stack<Node> s;  
    root.visited = true;  
    printf("%d ", root.val);     //访问  
    s.push(root);              //入栈  
    while (!s.empty())  
    {  
        Node pre= s.top();          //取栈顶顶点  
        int j;  
        for (j = 0; j<pre.adjacent.size(); j++)  //访问与顶点i相邻的顶点  
        {  
            Node cur = pre.adjacent[j];  
            if (cur.visited == false)  
            {  
                printf("%d ", cur.val);     //访问  
                cur.visited = true;  
                s.push(cur);           //访问完后入栈  
                break;               //找到一个相邻未访问的顶点，访问之后则跳出循环  
            }  
        }  
        //对于节点4，找完所有节点发现都已访问过或者没有临边，所以j此时=节点总数，然后把这个4给弹出来  
        //直到弹出1，之前的深度搜索的值都已弹出，有半部分还没有遍历，开始遍历有半部分  
        if (j == pre.adjacent.size())                   //如果与i相邻的顶点都被访问过，则将顶点i出栈  
            s.pop();  
    }  
}  
void BFS(Node root) {  
    queue<Node> q;  
    root.visited = true;  
    printf("%d ", root.val);     //访问  
    q.push(root);              //入栈  
    while (!q.empty()) {  
        Node pre = q.front();  
        q.pop();  
        for (Node cur : pre.adjacent) {  
            if (cur.visited == false) {  
                printf("%d ", cur.val);     //访问  
                cur.visited = true;  
                q.push(cur);  
            }  
        }  
    }  
}
－－－


————————————————
先序遍历（非递归）

非递归实现思路：使用栈来保存需要返回后处理的节点。

A：如果当前节点存在，则处理当前节点的value（先处理根节点的值），然后将当前节点入栈，当前节点指向leftChild，并对leftChild（此时的当前节点）进行相同处理。重复1
B：（当前节点不存在）当前节点指向栈顶元素，栈顶元素出栈，当前节点指向rightChild，并对rightChild（此时的当前节点）进行相同处理。重复1

//先序遍历（非递归）
void pre_visit(BTree* root)
{
    std::stack<BTree*> stack_tree;  //使用栈来保存需要返回再处理的元素
    BTree* cur_node = root;  //定义一个指针用来指向当前节点

    while(cur_node != NULL || !stack_tree.empty())
    {
        if(cur_node != NULL)
        {
            std::cout << cur_node->value.c_str() << "\t";  //处理当前节点的值

            stack_tree.push(cur_node);  //当前节点入栈
            cur_node = cur_node->leftChild;  //指向左子节点，进行相同处理
        }
        else
        {
            cur_node = stack_tree.top();  //指向栈顶元素，这里不会将栈顶元素出出栈
            stack_tree.pop();  //栈顶元素出栈
            cur_node = cur_node->rightChild;  //指向右子节点，进行相同处理
        }
    }
}


———————————— 
//树的高度
int TreeDepth(TreeNode* pRoot)
{
    if(pRoot==NULL) return 0;
    int lDeep=0, rDeep=0, deep;
    TreeNode *p=pRoot;      
    if(p!=NULL)
    { 
        lDeep=TreeDepth(p->left);
        rDeep=TreeDepth(p->right);
    }

    // 左子树高度+1, 右子树高度+1 中的较大者即为所求
    deep=(lDeep>=rDeep)?(lDeep+1):(rDeep+1);  

    return deep;
｝







